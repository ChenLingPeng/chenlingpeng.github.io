<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Developer in Tencent"><title>ebpf/sockhash 内核bug定位分析 | chenlingpeng</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ebpf/sockhash 内核bug定位分析</h1><a id="logo" href="/.">chenlingpeng</a><p class="description">hahahaha</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ebpf/sockhash 内核bug定位分析</h1><div class="post-meta">Jan 19, 2020</div><div class="post-content"><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在尝试使用bpf来优化istio场景下本地sidecar和app之间的数据传输，使用了ebpf/sockhash的特性。简单来讲，如果一台机器上有两个进程的sock存在相互收发数据的情况，我们就可以利用ebpf/sockhash将一个socket需要发送的数据跳过本机的底层tcp/ip协议栈直接交给本机的目的socket，缩短数据在内核的处理路径。</p>
<p>在测试过程中，我们发现一般的场景下网络都没有问题，数据包也确实跳过了协议栈直接转发给了对端的socket，但是当我们通过<code>python -m SimpleHTTPServer</code>启动一个server并通过curl访问时，发现大概率出现错误 <code>curl: (52) Empty reply from server</code>；如果通过curl从server下载一个稍大的文件，也经常出现下载不全的情况，且每次下载下来文件的大小不固定。但是这个情况只在 SimpleHTTPServer 中能复现，我尝试自己写一个go http server来传输数据下载文件发现都没有问题。难道是 SimpleHTTPServer 这个模块有什么特殊性？</p>
<p>通过tcpdump抓包，我们发现在python server中，在服务器端发送完数据后，就直接发送了FIN包。</p>
<p><img src="/images/tcpdump-fin.png" alt="tcpdump"></p>
<p>而对比无异常的服务，都是client在收完server包后先发送的FIN包，server收到FIN后再向client发起的FIN包。原来通过python自带模块起的http server只支持http1.0 协议，导致server端发完数据后即发送了FIN包。</p>
<p>在排除我们的程序有异常的情况下，怀疑内核本身在这一块对数据的处理可能存在bug, 尤其是收到FIN包之后的处理，可能收到FIN包后忽略了一些转发数据的处理。</p>
<h1 id="bug定位"><a href="#bug定位" class="headerlink" title="bug定位"></a>bug定位</h1><p>sockhash实际上是bpf中的一种特殊的map类型，存储的kv数据中value的类型实际是对应一个sock。除了存储sock，这类map上还可以attach一个用户编写的sk_msg类型的bpf程序来查找接收数据的socket。<br>在这里，我们通过attach一种sock_ops类型的bpf函数到cgroupv2的根路径，使得在发生一些socket事件（例如建立连接）时，通过这个bpf函数将sock对象放入到sockhash中。 将sock存储到sockhash时，内核会调用<code>net/core/sock_map.c</code>中的<code>sock_hash_update_common</code>函数，在这个函数中，会更新socket接收数据和发送数据的函数，将原先的 <code>tcp_recvmsg/tcp_sendmsg</code> 替换成 <code>tcp_bpf_recvmsg/tcp_bpf_sendmsg</code> 。重写的方法如下，其中的base就是默认的tcp_proto:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tcp_bpf_rebuild_protos</span><span class="params">(struct proto prot[TCP_BPF_NUM_CFGS],</span></span></span><br><span class="line"><span class="function"><span class="params">				   struct proto *base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	prot[TCP_BPF_BASE]			= *base;</span><br><span class="line">	prot[TCP_BPF_BASE].unhash		= tcp_bpf_unhash;</span><br><span class="line">	prot[TCP_BPF_BASE].close		= tcp_bpf_close;</span><br><span class="line">	prot[TCP_BPF_BASE].recvmsg		= tcp_bpf_recvmsg;</span><br><span class="line">	prot[TCP_BPF_BASE].stream_memory_read	= tcp_bpf_stream_read;</span><br><span class="line"></span><br><span class="line">	prot[TCP_BPF_TX]			= prot[TCP_BPF_BASE];</span><br><span class="line">	prot[TCP_BPF_TX].sendmsg		= tcp_bpf_sendmsg;</span><br><span class="line">	prot[TCP_BPF_TX].sendpage		= tcp_bpf_sendpage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在sock准备发送数据时，首先就会调用<code>tcp_bpf_sendmsg</code>。在tcp_bpf_sendmsg中，调用<code>tcp_bpf_send_verdict</code>，然后调用<code>sk_psock_msg_verdict</code>。而在<code>sk_psock_msg_verdict</code>中，会执行我们之前attach到sockhash上的用户自定义bpf程序。在这个BPF程序中，我们会根据发送者sock信息构造一个key值，然后调用<code>msg_redirect_hash</code>通过传入的key值来找到接收者的sock信息，将其存入当前sock的psock的sk_redir中。注意，虽然我们在bpf程序中调用的函数叫<code>msg_redirect_hash</code>, 但是实际上这个函数只是会负责根据key来找到接受方sock。执行完bpf程序拿到接收方sock信息后内核才负责调用<code>tcp_bpf_sendmsg_redir(sk_redir, msg)</code>，将数据放入sk_redir的<code>psock-&gt;ingress_msg</code>这个queue中，最后通知对端sock数据已经ready了（通过回调函数<code>sk-&gt;sk_data_ready</code>，实际调用<code>sock_def_readable</code>）。接收方sock此时再通过<code>tcp_bpf_recvmsg</code>从<code>ingress_msg</code>中读取数据。</p>
<p>为了定位内核问题，我们在我们的bpf程序中加了点log来打印发送端发送数据的大小，并通过内核提供的tracing手段kretprobe打印<code>tcp_bpf_recvmsg</code>的返回值来查看实际收到的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /sys/kernel/debug/tracing/</span><br><span class="line">echo &apos;r:kprobes/myretprobe tcp_bpf_recvmsg ret=$retval&apos; &gt; kprobe_events</span><br><span class="line">echo 1 &gt; events/kprobes/enable</span><br><span class="line">cat trace_pipe</span><br></pre></td></tr></table></figure></p>
<p>在无异常情况下，我们可以看到下图的结果。</p>
<p><img src="/images/tcp_bpf_normal.png" alt="normal"></p>
<p>可以看到，在正常情况下，tcp_bpf_recvmsg的返回值是0x23e=574, 等于发送端发送的数据总和。</p>
<p>而在异常情况下，我们看到的结果如下</p>
<p><img src="/images/tcp_bpf_fail.png" alt="fail"></p>
<p>可以看到，虽然发送方发送了多组数据，但是<code>tcp_bpf_recvmsg</code>返回值是0，说明在此次读取中，并没有读到数据。</p>
<p>为了搞清楚此时<code>tcp_bpf_recvmsg</code>的执行情况，使用ftrace提供的<code>graph_function</code> trace功能，打印出了<code>tcp_bpf_recvmsg</code>下函数的的调用情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /sys/kernel/debug/tracing/</span><br><span class="line">echo tcp_bpf_recvmsg &gt; set_graph_function</span><br><span class="line">echo 3 &gt; max_graph_depth</span><br><span class="line">echo function_graph &gt; current_tracer</span><br><span class="line">cat trace_pipe</span><br></pre></td></tr></table></figure></p>
<p>可以看到，进入<code>tcp_bpf_recvmsg</code>后直接调用了tcp_recvmsg函数，结合tcp_bpf_recvmsg的源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_bpf_recvmsg</span><span class="params">(struct sock *sk, struct msghdr *msg, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">		    <span class="keyword">int</span> nonblock, <span class="keyword">int</span> flags, <span class="keyword">int</span> *addr_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (!skb_queue_empty(&amp;sk-&gt;sk_receive_queue))</span><br><span class="line">#<span class="number">1</span>		<span class="keyword">return</span> tcp_recvmsg(sk, msg, len, nonblock, flags, addr_len);</span><br><span class="line"></span><br><span class="line">	psock = sk_psock_get(sk);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!psock))</span><br><span class="line">#<span class="number">2</span>		<span class="keyword">return</span> tcp_recvmsg(sk, msg, len, nonblock, flags, addr_len);</span><br><span class="line">msg_bytes_ready:</span><br><span class="line">	copied = __tcp_bpf_recvmsg(sk, psock, msg, len, flags);</span><br><span class="line">	<span class="keyword">if</span> (!copied) &#123;</span><br><span class="line">		data = tcp_bpf_wait_data(sk, psock, flags, timeo, &amp;err);</span><br><span class="line">		<span class="keyword">if</span> (data) &#123;</span><br><span class="line">			<span class="keyword">if</span> (skb_queue_empty(&amp;sk-&gt;sk_receive_queue))</span><br><span class="line">				<span class="keyword">goto</span> msg_bytes_ready;</span><br><span class="line">#<span class="number">3</span>			<span class="keyword">return</span> tcp_recvmsg(sk, msg, len, nonblock, flags, addr_len);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (err) &#123;</span><br><span class="line">			ret = err;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		copied = -EAGAIN;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = copied;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到共有3出可能出现调用<code>tcp_recvmsg</code>，首先可以排除第3处的调用，因为如果是在第3处执行的，那么必然会先调用<code>__tcp_bpf_recvmsg</code>，而在ftrace中我们并没有发现对<code>__tcp_bpf_recvmsg</code>的调用。由于前面怀疑是因为FIN包的出现导致未能正常处理由tcp_bpf_sendmsg转发的包，所以怀疑是这里是因为第1处触发的<code>tcp_recvmsg</code>，也就是<code>sk_receive_queue</code>不为空。为了证实这个猜想，我们希望能通过tracing的手段来确认。由于对kprobe功能不是很熟悉，不知如何才能确定，这时候就用上了bpf的krpobe tracing功能。通过编写bpf程序并attack到<code>tcp_bpf_recvmsg</code>上，我们可以获取到sock对象并由此来判断<code>sk_receive_queue</code>。通过<a href="https://github.com/iovisor/bcc" target="_blank" rel="noopener">iovisor/bcc</a>, 可以通过编写python代码来方便的操作bpf程序，bpf源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello_bpf_recv</span><span class="params">(struct pt_regs *ctx)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = (<span class="title">struct</span> <span class="title">sock</span> *)<span class="title">PT_REGS_PARM1</span>(<span class="title">ctx</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_psock</span> *<span class="title">psock</span>;</span></span><br><span class="line">    u32 l = sk-&gt;sk_receive_queue.qlen;</span><br><span class="line">    bpf_trace_printk(<span class="string">"Hello, sk_receive_queue len is %d!\\n"</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重新执行后，发现果然打印出来了len为1，基本验证了之前的猜想。当然，我们还可以进一步通过bpf程序验证一下这个queue里面的包是不是一个FIN包。通过跟踪内核代码，我们可以大概定位<code>tcp_data_queue</code>这个函数会将收到的包发如到这个queue中，我们可以在这个函数上attack一个bpf/kprobe程序，完整的程序在<a href="/attach/tcp_bpf_recv.py">这里</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int hellp_tcp_data_queue(struct pt_regs *ctx) &#123;</span><br><span class="line">    struct sk_buff *skb = (struct sk_buff *)PT_REGS_PARM2(ctx);</span><br><span class="line">    u16 sport = 0, dport = 0;</span><br><span class="line">    struct tcphdr *tcp = skb_to_tcphdr(skb);</span><br><span class="line">    sport = tcp-&gt;source;</span><br><span class="line">    dport = tcp-&gt;dest;</span><br><span class="line">    sport = ntohs(sport);</span><br><span class="line">    dport = ntohs(dport);</span><br><span class="line">    if (sport == 8080 || dport == 8080) &#123;</span><br><span class="line">        u8 tcpflags = ((u_int8_t *)tcp)[13];</span><br><span class="line">        u32 seq = tcp-&gt;seq;</span><br><span class="line">        seq = ntohl(seq);</span><br><span class="line">        bpf_trace_printk(&quot;tcp_data_queue for 8080, seq %u\\n&quot;, seq);</span><br><span class="line">        if (tcpflags &amp; 0x01) &#123;</span><br><span class="line">            bpf_trace_printk(&quot;tcp_data_queue get fin\\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (tcpflags &amp; 0x02) &#123;</span><br><span class="line">            bpf_trace_printk(&quot;tcp_data_queue get syn\\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (tcpflags &amp; 0x10) &#123;</span><br><span class="line">            bpf_trace_printk(&quot;tcp_data_queue get ack\\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/trace_fin.png" alt="trace_fin"></p>
<p>可以看到trace_pipe中可以打印出收到了FIN包</p>
<p>问题到这里基本就定位结束了，可以基本确定在收到FIN包后，client端认为server端已经没有数据可以读取了，所以直接通过sockhash redirect机制传输的存储在psock-&gt;ingress_msg中的数据还没有被读取完就释放了。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>可以看到，目前的逻辑是，当收到FIN包时会存储到<code>sk_receive_queue</code>中，<code>tcp_bpf_recvmsg</code>会优先从这里拿数据。一旦拿到FIN包，内核认为对端socket已经没有数据需要读取了，就不会再从ingress_msg里读数据了，但是数据未完全读完。<br>所以这里提出的解决方案也比较简单粗暴，修改<code>tcp_bpf_recvmsg</code>，如果有ingress_msg有数据，优先读取ingress_msg里的数据。<br>目前该patch已经被社区接受并合并到了内核bpf repo中，可在<a href="https://github.com/torvalds/linux/commit/e7a5f1f1cd0008e5ad379270a8657e121eedb669" target="_blank" rel="noopener">这里</a>查看该patch。</p>
</div><div class="tags"><a href="/tags/ebpf/">ebpf</a><a href="/tags/kernel/">kernel</a></div><div class="post-nav"><a class="pre" href="/2020/08/13/ebpf-code-skill/">ebpf code skill</a><a class="next" href="/2020/01/08/linux-kernel-build-and-submit-patch/">linux 内核源码修改编译与patch提交</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://chenlingpeng.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-System/">Distributed System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/lang/">lang</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/others/" style="font-size: 15px;">others</a> <a href="/tags/neural-network/" style="font-size: 15px;">neural network</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/Distributed-System/" style="font-size: 15px;">Distributed System</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/kubelet/" style="font-size: 15px;">kubelet</a> <a href="/tags/lang/" style="font-size: 15px;">lang</a> <a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/tc/" style="font-size: 15px;">tc</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/tcpdump/" style="font-size: 15px;">tcpdump</a> <a href="/tags/calico/" style="font-size: 15px;">calico</a> <a href="/tags/ebpf/" style="font-size: 15px;">ebpf</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/08/13/ebpf-code-skill/">ebpf code skill</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/19/ebpf-sockhash-debug/">ebpf/sockhash 内核bug定位分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/08/linux-kernel-build-and-submit-patch/">linux 内核源码修改编译与patch提交</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/07/ebpf-intro/">ebpf intro</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/23/k8s-service-ip-problem/">k8s service ip problem</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/04/k8s-floatingip-evolution/">k8s floatingip evolution</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/22/sriov-getting-start/">sriov getting start</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/18/ipvs-attempt/">ipvs attempt</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/30/iptables-quick-start/">iptables quick start</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/16/calico-getting-start/">calico getting start</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">chenlingpeng.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>