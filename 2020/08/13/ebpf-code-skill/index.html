<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Developer in Tencent"><title>ebpf code skill | chenlingpeng</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ebpf code skill</h1><a id="logo" href="/.">chenlingpeng</a><p class="description">hahahaha</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ebpf code skill</h1><div class="post-meta">Aug 13, 2020</div><div class="post-content"><pre><code>本文介绍编写 ebpf 程序时可能遇到的坑或注意事项，持续更新中
</code></pre><ol start="0">
<li><p>最大的原则：不要一次性写太多代码！！！</p>
<p> 每次写少量代码后都需要编译测试，千万不要一次性写太多逻辑。否则一旦代码有问题，导致无法load到内核，非常难定位具体错在哪。ebpf的报错信息实在太坑爹，这也是为什么会有本文的原因</p>
</li>
<li><p>ntohs</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u16 sport = skb-&gt;sport;</span><br><span class="line">sport = ntohs(sport);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="comment">// u16 sport = ntohs(skb-&gt;sport);</span></span><br></pre></td></tr></table></figure>
<p> 下面错误的写法在加载时会报 ‘permission deny’ 错误。</p>
</li>
<li></li>
</ol>
<p>从map中lookup出来的指针，不能直接update回去，在ebpf代码中更新值之后不再需要重新update，因为拿到了引用</p>
<ol start="3">
<li><p>struct初始化问题</p>
<p> 定义结构体</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_SIDE 0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_info</span> &#123;</span></span><br><span class="line">    u64 ts;</span><br><span class="line">    u32 direct:<span class="number">1</span>,</span><br><span class="line">        flag1:<span class="number">7</span>,</span><br><span class="line">        flag2:<span class="number">8</span>,</span><br><span class="line">        flag3:<span class="number">16</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p> 按以下方式初始化结构体会报错</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_info</span> <span class="title">info</span> = &#123;</span></span><br><span class="line">.ts = <span class="number">0</span>,</span><br><span class="line">.direct = SERVER_SIDE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 需要先声明 <code>u64 ts = 0</code> 然后赋值</p>
</li>
<li><p>字符串拷贝可以使用编译器内置的 <code>__builtin_memcpy</code></p>
</li>
<li><p>关于从kretprobe中获取函数入参</p>
<p> kretprobe获取函数入参，使用<code>ctx-&gt;bx</code></p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kretprobe__tcp_set_state</span><span class="params">(structpt_regs*ctx)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span>*<span class="title">sk</span>=(<span class="title">void</span>*)<span class="title">ctx</span>-&gt;<span class="title">bx</span>;</span></span><br><span class="line">u16 dport = sk-&gt;__sk_common.skc_dport;</span><br><span class="line">dport = ntohs(dport);</span><br><span class="line">u16 sport=sk-&gt;__sk_common.skc_num;</span><br><span class="line">u32 daddr=sk-&gt;__sk_common.skc_daddr;</span><br><span class="line">u32 saddr=sk-&gt;__sk_common.skc_rcv_saddr;</span><br><span class="line"><span class="keyword">if</span>(sport == <span class="number">8087</span> || dport==<span class="number">8087</span>)&#123;</span><br><span class="line">    u32 state=(u32)ctx-&gt;cx;</span><br><span class="line">    bpf_trace_printk(<span class="string">"sport %d dport %d state %d\n"</span>,sport,dport,state);</span><br><span class="line">&#125;</span><br><span class="line">return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 但是，目前只能获取第一个参数，第二个参数用ctx-&gt;cx无法获取（虽然不报错）</p>
<p> 注：问了社区的人，ctx-&gt;bx这种做法也是不保证对的，这里能获取到有一定的lucky成份</p>
</li>
<li><p>获取当前进程cgroup path</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">task = (struct task_struct *)bpf_get_current_task();</span><br><span class="line">u32 nr_tasks = task-&gt;cgroups-&gt;nr_tasks;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> path[<span class="number">100</span>];</span><br><span class="line">u32 readn = bpf_probe_read_str(&amp;name, <span class="keyword">sizeof</span>(name), task-&gt;sched_task_group-&gt;css.cgroup-&gt;kn-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (task-&gt;sched_task_group-&gt;css.cgroup-&gt;kn-&gt;parent) &#123;</span><br><span class="line">    u32 len = bpf_probe_read_str(&amp;path, <span class="keyword">sizeof</span>(path), task-&gt;sched_task_group-&gt;css.cgroup-&gt;kn-&gt;parent-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path[<span class="number">0</span>]==<span class="string">'p'</span> &amp;&amp; path[<span class="number">1</span>]==<span class="string">'o'</span>&amp;&amp;path[<span class="number">2</span>]==<span class="string">'d'</span>) &#123;</span><br><span class="line">            <span class="comment">// this is a pod</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遇到有些struct并没有出自linux标准header定义里，需要自己在代码里伪造一个</p>
<p> 例如上例中的<code>sched_task_group-&gt;css</code>, 需要自己定义：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct task_group &#123;</span><br><span class="line">    struct cgroup_subsys_state css;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再谈 kretprobe</p>
<p> 关于获取kretprobe的方式，一般是配合kprobe使用，在kprobe中用pid_tgid作为key来存储信息，在kretprobe中用pid_tgid来取出信息；这里的疑问是，比如在go的GPM调度模型中G(goroutine)是可以跨M调度的，如果当前G在M中执行时，在执行到kprobe存储信息之后，由于时间片已消耗被linux调度器抢占执行其他线程，那么恢复goroutine执行逻辑的时候可能已经跑到别的M上执行了，此时在执行kretprobe的时候，pid_tgid会发生变化。或者还有一种情况，在M重新被调度指挥，go的调度器此时会另一个goroutine来执行，此时如果也触发了kprobe, 相对于再次存储，覆盖了刚才存储的信息。</p>
</li>
<li><p>map空间问题</p>
<p> bcc下bpf map有默认值，有时候需要注意下是否足够，例如我之前用BPF_HASH来记录tcp连接情况，可能默认的10240是不够的</p>
</li>
<li><p>gobpf库读取percpu map问题</p>
<p>目前gobpf库使用Get/GetP读取map value时，当map类型是percpu类型时，无法完成取出每个cpu对应的值，需要做相应改变，对应的<a href="https://github.com/iovisor/gobpf/pull/254/files" target="_blank" rel="noopener">PR</a></p>
</li>
<li><p>可以使用<code>lock_xadd</code>来解决并发写问题，不过如果可能的话尽量使用 percpu 相关的map来进行计数等操作。</p>
<p><code>lock_xadd</code>其实也是调用的<code>__sync_fetch_and_add</code></p>
</li>
<li><p>linux版本相关的条件编译 <code>#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(4, 14, 0)</code></p>
</li>
<li><p>有限的for循环</p>
<p>ebpf本身不允许循环的存在，因为会被判定为可能无法及时退出，影响内核执行效率。不过我们如果可以预见到循环将在有限次循环之后退出，可以使用<code>#pragma unroll</code>来在编译期间展开for循环，通过bpf的verify组件。当然，循环的次数是有限的，因为bpf本身代码指令的数量有限(4096)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __inline <span class="keyword">int</span> <span class="title">is_prefix</span><span class="params">(<span class="keyword">char</span> *prefix, <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> unroll</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_PATH_PREF_SIZE; prefix++, str++, i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!*prefix)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*prefix != *str) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prefix is too long</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断是不是创建了一个容器(pid_namespace)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline u32 <span class="title">get_task_ns_pid</span><span class="params">(struct task_struct *task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(4, 19, 0)</span></span><br><span class="line">    <span class="comment">// kernel 4.14-4.18:</span></span><br><span class="line">    <span class="keyword">return</span> task-&gt;pids[PIDTYPE_PID].pid-&gt;numbers[task-&gt;nsproxy-&gt;pid_ns_for_children-&gt;level].nr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// kernel 4.19 onwards:</span></span><br><span class="line">    <span class="keyword">return</span> task-&gt;thread_pid-&gt;numbers[task-&gt;nsproxy-&gt;pid_ns_for_children-&gt;level].nr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过判断<code>get_task_ns_pid</code>是否是1来判断是否新的进程是创建在容器里的, trace点在系统调用<code>execve</code>和<code>execveat</code>, 进程退出点在<code>do_exit</code></p>
</li>
<li><p>获取参数问题</p>
<p>有2中方式可以获取kprobe触发函数的参数，一个是使用<code>PT_REGS_PARMN</code>的形式来获取，另一个是在你的kprobe hook函数上直接申明。对于复杂的数据结构，建议使用第2中方式直接在函数参数中声明，否则可能读不出来，load BPF程序的时候会报错。<a href="https://github.com/iovisor/bcc/issues/3086" target="_blank" rel="noopener">issue3086</a></p>
</li>
<li><p>BPF_PERCPU_HASH</p>
<p>bcc目前没有定义<code>BPF_PERCPU_HASH</code>这个宏，需要使用的话可以用 <code>BPF_TABLE(&quot;percpu_hash&quot;, _key_type, _leaf_type, _name, _size)</code> 来定义</p>
</li>
<li><p>stack空间限制512byte</p>
<p>一个bpf程序不能申请太多的栈空间，目前限制512B，多了就会报错：<code>Looks like the BPF stack limit of 512 bytes is exceeded.</code>。<br>例如在程序中申请了两个数组<code>char arr1[256];char arr2[256];</code>程序就会报错了</p>
</li>
<li><p>bpf程序需要特权</p>
<p>加载bpf程序需要一定的特权，比如使用bpf syscall需要SYS_ADMIN权限。所以我们在docker中跑的时候一般使用<code>--privileged</code>。如果在k8s环境，有些环境可能并不能直接使用privileged，此时需要使用capabilities来给bpf程序必要的权限。测试会发现，只添加SYS_ADMIN权限还是不够的，运行时会报类似<code>could not open bpf map: cstat, error: Operation not permitted</code>的错误。strace一下系统调用可以看到，权限问题是在调用prlimit64时出现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prlimit64(0, RLIMIT_MEMLOCK, NULL, &#123;rlim_cur=64*1024, rlim_max=64*1024&#125;) = 0</span><br><span class="line">prlimit64(0, RLIMIT_MEMLOCK, &#123;rlim_cur=RLIM64_INFINITY, rlim_max=RLIM64_INFINITY&#125;, NULL) = -1 EPERM (Operation not permitted)</span><br></pre></td></tr></table></figure>
<p>查阅资料可知，要设置memlock，除了SYS_ADMIN，还需要SYS_RESOURCE</p>
</li>
</ol>
</div><div class="tags"><a href="/tags/ebpf/">ebpf</a><a href="/tags/kernel/">kernel</a></div><div class="post-nav"><a class="next" href="/2020/01/19/ebpf-sockhash-debug/">ebpf/sockhash 内核bug定位分析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://chenlingpeng.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-System/">Distributed System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/lang/">lang</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/others/" style="font-size: 15px;">others</a> <a href="/tags/neural-network/" style="font-size: 15px;">neural network</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/Distributed-System/" style="font-size: 15px;">Distributed System</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/kubelet/" style="font-size: 15px;">kubelet</a> <a href="/tags/lang/" style="font-size: 15px;">lang</a> <a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/tc/" style="font-size: 15px;">tc</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/tcpdump/" style="font-size: 15px;">tcpdump</a> <a href="/tags/calico/" style="font-size: 15px;">calico</a> <a href="/tags/ebpf/" style="font-size: 15px;">ebpf</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/08/13/ebpf-code-skill/">ebpf code skill</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/19/ebpf-sockhash-debug/">ebpf/sockhash 内核bug定位分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/08/linux-kernel-build-and-submit-patch/">linux 内核源码修改编译与patch提交</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/07/ebpf-intro/">ebpf intro</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/23/k8s-service-ip-problem/">k8s service ip problem</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/04/k8s-floatingip-evolution/">k8s floatingip evolution</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/22/sriov-getting-start/">sriov getting start</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/18/ipvs-attempt/">ipvs attempt</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/30/iptables-quick-start/">iptables quick start</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/16/calico-getting-start/">calico getting start</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">chenlingpeng.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>