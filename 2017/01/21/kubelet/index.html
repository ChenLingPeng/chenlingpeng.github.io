<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Developer in Tencent"><title>Kubelet Introduction | chenlingpeng</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Kubelet Introduction</h1><a id="logo" href="/.">chenlingpeng</a><p class="description">hahahaha</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Kubelet Introduction</h1><div class="post-meta">Jan 21, 2017</div><div class="post-content"><blockquote>
<p>kubernetes(k8s)是一个开源的分布式容器集群管理系统，用户对容器进行部署，扩展和管理。</p>
</blockquote>
<p>kubelet是k8s中重要的工作模块。每个kubernetes集群的实际工作节点上都需要运行这个一个进程(agent)来进行实际作业（pod/container）的运行，类似于NodeManager在Yarn集群中的地位。在kunernetes架构下，pod是作业运行的最小单元。PodSpec描述一个Pod作业的具体信息，kubelet的主要作用就是通过一定的机制（如从apiserver）拿到这些PodSpec在本地对PodSpec中描述的container信息进行执行，并保证PodSpec中描述的container信息与实际运行的container一致，并对这些pod/container状态信息实时上报到apiserver。</p>
<blockquote>
<p>apiserver 是k8s中的重要组件，apiserver代理了其他组件（kubelet, scheduler, controller等）对资源的读写操作，目前以rest接口的形式提供。apiserver提供了对单个资源(pod/deployment等)的增删改查，对一类资源的list/watch等功能。</p>
</blockquote>
<p>kubelet的核心代码在pkg/kubelet下，由于其涉及到的模块很多，所以下面又有多个子包分别负责不同的事物处理。另外还有例如volume管理的代码在外部支持。主要的工作组件如图所示：</p>
<p><img src="/images/kubelet.png" alt="kubelet"></p>
<blockquote>
<p>在kubelet启动之后，会有一个主循环从各个渠道（具体下面阐述）获取Pod的状态更新。将这个Pod的更新通知到PodWorkers，由PodWorkers去完成对Pod的管理。</p>
</blockquote>
<h1 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h1><p>kubelet包的主要包括以下几个重要组件：</p>
<h2 id="PLEG"><a href="#PLEG" class="headerlink" title="PLEG"></a>PLEG</h2><p>PLEG(Program Logic Event Generator), 即由程序逻辑事件生成器。在kubelet中，由PLEG组件对本机上运行的pod/container状态进行周期性的检查，并根据状态的变化(转移)生成container的相应事件交给kubelet相关组件处理（如图）。</p>
<p><img src="/images/pleg-container-events.png" alt="pleg1"></p>
<p>例如，在周期性的检查中可以发现一个在上次还处于ContainerCreate的container现在已经是ContainerRunning了，就会发出一个ContainerStarted事件放到pleg的channel中供下文中提到的PodWorkers处理，根据这个状态变化，podWorkers会重新检查当前pod下的container是否正如PodSpec中定义的一样运行。</p>
<p>在周期性检查中，PLEG组件还会通过containerRuntime提供的接口去获取本地Pod下container的运行状态进行缓存(放在podCache中)，podWorkers的操作会用到cache中的container状态去往apiserver更新pod状态。这个的好处是如果同一个pod同时有多个状态变化请求，可以直接从cache中拿到container状态而不用每次都调用containerRuntime接口。</p>
<h2 id="StatusManager"><a href="#StatusManager" class="headerlink" title="StatusManager"></a>StatusManager</h2><p>StatusManager, 负责管理Pod的状态信息。其主要工作是将本地的Pod状态的更新信息同步到apiserver上。主要体现在SetPodStatus/SetContainerReadiness/TerminatePod三个方法，分别是设置Pod的状态，container的Ready状态以及删除apiserver上的Pod。其中SetContainerReadiness方法被ProbeManager的readinessProbe调用。SetPodStatus在pod被reject或者进行podWorker sync的时候调用，将本地的pod状态更新到apiserver。TerminatePod在kubelet不断获取pod的更新时如果发现Pod已经终止且可以删除(DeletionTimestamp)，则会调用Delete接口删除apiserver的Pod。</p>
<h2 id="PodManager"><a href="#PodManager" class="headerlink" title="PodManager"></a>PodManager</h2><p>PodManager维护了apiserver上的Pod的本地映射。所有调度到本kubelet的pod都可以在这里找到。此外，对于staticPod，会在apiserver上创建对应的mirrotPod，PodManager还维护了这部分的信息映射。</p>
<h2 id="ProbeManager"><a href="#ProbeManager" class="headerlink" title="ProbeManager"></a>ProbeManager</h2><p>ProbeManager负责对pod中container定义的ReadinessProbe和LivenessProbe进行处理，即对container进行用户自定义的健康检查。ProbeManager对每个container的ReadinessProbe和LivenessProbe都创建一个worker，在自己的goroutine中执行probe。对于不同的probe，分别会将结果放到readinessManager/livenessManager中。对于readiness类型的probe，probeManager会不断从这个manager中得到结果并调用statusManager的SetContainerReadiness接口更新pod状态到apiserver。对于liveness的probe，在kubelet的周期循环中会得到livenessProbe的结果重新触发Pod的同步，不健康的container会根据重启策略进行重启或者将状态置为failed。</p>
<p>此外，ProbeManager中提供了 UpdatePodStatus 方法，用于在podworkers sync时设置Pod中containerStatus的Ready字段。</p>
<h2 id="PodWorkers"><a href="#PodWorkers" class="headerlink" title="PodWorkers"></a>PodWorkers</h2><p>PodWorkers在之前已经提到过，负责对Pod的更新作出处理。PodWorker实际相当于一个Pod处理的中转站，所有Pod的本地同步处理都经过它发起，由它控制<em>相同Pod在一个goroutine中串行处理</em>。处理时会拿到Pod最新的运行时状态进行处理。主要调用kubelet的syncPod函数，由该函数完成实际的pod管理。这部分具体另起文章详细介绍。</p>
<h2 id="ContainerRuntime"><a href="#ContainerRuntime" class="headerlink" title="ContainerRuntime"></a>ContainerRuntime</h2><p>ContainerRuntime是管理运行时态Pod(container)的重要组件，即操作底层的runtime来执行用户定义的podSpec。例如docker_tool包下面的runtime属于docker。ContainerRuntime本身是一个接口定义，定义了实现这个接口的具体底层需要完成的功能，根据底层来具体选择这个Runtime（docker/rkt）。目前kubelet还在实现CRI形式进行管理。Runtime接口实现了对runtime的管理，常用的接口包括GetPods, KillPod, GetPodStatus(获取pod的container的状态), DeleteContainer. 最主要的一个接口是SyncPod，在podWorker调用syncPod时调用。SyncPod负责创建container，设置网络，设置cgroup参数，维护实际运行状态与PodSpec一致性等。这部分具体实现(docker)另起文章详细介绍。</p>
<h2 id="EvictManager"><a href="#EvictManager" class="headerlink" title="EvictManager"></a>EvictManager</h2><p>这个组件主要用于维护kubelet节点的稳定性，主要利用cAdvisor监控机器运行状态，Mem/Disk等。如果调度到本地的Pod运行可能影响节点的稳定性，就会将这个Pod进行Evict操作，killPod并将其状态置为Failed。</p>
<h2 id="cAdvisor"><a href="#cAdvisor" class="headerlink" title="cAdvisor"></a>cAdvisor</h2><p>TODO</p>
<h2 id="VolumeManager"><a href="#VolumeManager" class="headerlink" title="VolumeManager"></a>VolumeManager</h2><p>TODO</p>
<h2 id="Network-plugin"><a href="#Network-plugin" class="headerlink" title="Network plugin"></a>Network plugin</h2><p>TODO</p>
<h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><p>kubelet启动后需要向apiserver主动注册节点。scheduler发现节点后可以将pod调度到该节点上。<br>kubelet会watch apiserver中那些pod.NodeName = this.NodeName的pod，放到PodUpdates的chan中给kubelet进行处理。其实除了从apiserver获取pod资源，还可以从本地文件或者自定义的http endpoint中得到pod，这些渠道获取的Pod被称为static pod，会在apiserver创建对应的pod称为mirror pod。</p>
<p>kubelet的工作从syncLoop发起，syncLoop主要获取构造几个channel，一个是从apiserver监听的pod变化的事件（包括创建，更新，删除），一个是syncTicker，负责每秒发送一个tick出发一些更新（下面会讲到），一个是housekeepingTicker，每15s触发一次，进行housekeeping的操作，最后一个是由pleg生成的channel，这里会生成一些container变更的事件给主程序进行处理。<br>构造完后将这几个channel交给syncLoopIteration处理，每次select出一个channel进行事件处理。</p>
<ol>
<li>如果有从apiserver来的pod，则调用HandlePodXXX来进行事件处理，</li>
<li>如果从pleg有container的事件且不是container移除的事件，则调用HandlePodSyncs来重新同步pod的container的状态信息。另外如果container的事件是ContainerDied的话，还会触发会pod中container的cleanup操作，使得一个pod的退出的container数不超过一定值。</li>
<li>如果有来自livenessManager的关于container的livenessProbe的失败结果，也调用HandlePodSyncs接口。</li>
<li>如果收到来自housekeeping的事件（每15秒一次），则调用HandlePodCleanups进行一些已经移除的pod的清理工作</li>
<li>如果收到来自syncCh的事件（每秒一次），则拿到需要重新同步的pod，需要同步的pod主要从workQueue的chan中获取，由podWorkers在同步了pod之后放入workQueue中一定事件后从workQueue的chan中拿出。调用HandlePodSyncs。</li>
</ol>
<p>HandlePodXXX方法基本都是调用dispatchWork，在这个函数中调用podWorkers的UpdatePod函数对pod进行实际的处理（调用kubelet.syncPod方法）。另外HandlePodAdditions和HandlePodRemoves还会在probeManager注册/注销containerProbe。</p>
<p>podWorkers给每个pod创建一个goroutine执行kubelet的syncPod函数，首先根据现在的podStatus生成apiPodStatus，然后调用statusManager的SetPodStatus方法将status更新到apiserver。创建相关的pod目录，将volume挂载到本地，从apiserver获取pull secret，然后到最重要的一步，调用containerRuntime的SyncPod方法，这里调用的docker_tool下面的dockerManager的SyncPod方法。把sync的结果保存到reasonCache中。</p>
<p>podWorkers处理之后会将pod放入到workQueue中供后续syncCh拿出重新同步状态，使得Pod的containers始终遵循pod的spec内容。</p>
<hr>
<p>一个Pod的执行流程大体如上所诉。总结来说，从pod被调度器调度到kubelet节点开始，kubelet watch到该pod，将pod放到kubelet的循环中处理。首先将其放入probeManager对readiness/liveness进行定期probe。然后放入podWorker中，在podWorker中调用kubelet.syncPod，将最新的pod status同步到apiserver，设置本地目录，mount相关的volume，获取image的pull secret，然后调用containerRuntime的SyncPod（在SyncPod中拉去image，启动container）。然后将pod放入到workQueue中。等到pod在workQueue中到达一个时间点，或者Pod/Container有变化，重新通过kubelet主循环放到podWorker中重新处理，重新生成podStatus，重新调用SyncPod等。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除了以上这些跟Pod处理直接相关的模块外，kubelet还有一些其他的模块。例如evict模块负责对调度到本地的Pod进行审查，决定是否需要拒绝这个Pod。containerGC和imageGC负责定期清理本地退出的container和image。cadvisor模块监控本地资源的运行使用情况。OOM负责为container的OOMAdjust打分，控制资源的使用。网络模块负责设置Pod的网络模式。此外，kubelet本身也起了一个http server，通过接口可以获取到本地Pod/Container的一些信息。</p>
<h1 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h1><p>目前，kubelet有一些重要的特性在进行需要关注，例如多卡GPU的支持，Pod level cgroup的支持，kubelet CRI等。</p>
</div><div class="tags"><a href="/tags/kubernetes/">kubernetes</a><a href="/tags/kubelet/">kubelet</a></div><div class="post-nav"><a class="pre" href="/2017/02/28/traffic-control/">Traffic control</a><a class="next" href="/2015/11/28/Distributed-Systems-course-6.824-lab2/">Distributed Systems Course 6.824 lab 2</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://chenlingpeng.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-System/">Distributed System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/lang/">lang</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/others/" style="font-size: 15px;">others</a> <a href="/tags/neural-network/" style="font-size: 15px;">neural network</a> <a href="/tags/Distributed-System/" style="font-size: 15px;">Distributed System</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/lang/" style="font-size: 15px;">lang</a> <a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/calico/" style="font-size: 15px;">calico</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/kubelet/" style="font-size: 15px;">kubelet</a> <a href="/tags/tc/" style="font-size: 15px;">tc</a> <a href="/tags/tcpdump/" style="font-size: 15px;">tcpdump</a> <a href="/tags/ebpf/" style="font-size: 15px;">ebpf</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/08/13/ebpf-code-skill/">ebpf code skill</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/19/ebpf-sockhash-debug/">ebpf/sockhash 内核bug定位分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/08/linux-kernel-build-and-submit-patch/">linux 内核源码修改编译与patch提交</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/07/ebpf-intro/">ebpf intro</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/23/k8s-service-ip-problem/">k8s service ip problem</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/04/k8s-floatingip-evolution/">k8s floatingip evolution</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/22/sriov-getting-start/">sriov getting start</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/18/ipvs-attempt/">ipvs attempt</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/30/iptables-quick-start/">iptables quick start</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/16/calico-getting-start/">calico getting start</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">chenlingpeng.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>