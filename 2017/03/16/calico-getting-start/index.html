<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Developer in Tencent"><title>calico getting start | chenlingpeng</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">calico getting start</h1><a id="logo" href="/.">chenlingpeng</a><p class="description">hahahaha</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">calico getting start</h1><div class="post-meta">Mar 16, 2017</div><div class="post-content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://www.projectcalico.org/" target="_blank" rel="noopener">Calico</a>是一个纯3层虚拟网络，可以为夸主机的容器/虚拟机等提供网络访问，同时支持IPv4和IPv6。并且可以根据策略提供访问控制能力。</p>
<p>Calico的工作原理主要依靠linux本身提供的ip转发机制，不需要虚拟交换设备或者overlay支持。每一个主机都会将自己的路由信息告知数据中心网络中的其他主机：在小型网络中，直接通过BGP协议交换信息；在大型网络中，通过BGP route reflectors完整路由信息的交换。</p>
<p>Calico为各个不同的云环境提供了不同的插件来使用calico网络，kubernetes和mesos通过CNI插件形式使用calico，docker使用libnetwork插件使用calico网络进行跨主机容器间通信。OpenStack使用Neutron插件使用calico。</p>
<h1 id="入门实践"><a href="#入门实践" class="headerlink" title="入门实践"></a>入门实践</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>这里根据<a href="http://docs.projectcalico.org/v2.0/getting-started/docker/installation/vagrant-ubuntu/" target="_blank" rel="noopener">官网教程</a>使用vagrant进行docker+calico初始环境搭建。官方文档还提供了手动环境搭建的流程，但是由于一些坑（跨主机容器不能相互访问）放弃了，后来在vagrant上解决了也懒得重新解决一遍了。</p>
<p>搭建命令如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 需要在主机上有git/vagrant/virtualbox</span><br><span class="line">git clone https://github.com/projectcalico/calico.git</span><br><span class="line">cd calico/v2.0/getting-started/docker/installation/vagrant-ubuntu</span><br><span class="line"><span class="meta">#</span> 初始化虚拟机环境，此命令会创建两个主机calico-01/calico-02，且在01上运行了etcd</span><br><span class="line">vagrant up</span><br><span class="line"><span class="meta">#</span> 验证环境</span><br><span class="line">vagrant ssh calico-01 # ssh into calico-01 host</span><br><span class="line">ping 172.17.8.102 # ping calico-02 in calico-01</span><br><span class="line"><span class="meta">#</span> run calico/node</span><br><span class="line">sudo calico node run</span><br><span class="line"><span class="meta">#</span> 查看运行</span><br><span class="line">docker ps</span><br><span class="line">exit # exit from calico-01</span><br><span class="line">vagrant ssh calico-02 # ssh into calico-02 host</span><br><span class="line">sudo calico node run</span><br><span class="line"><span class="meta">#</span> 查看BGP信息</span><br><span class="line">sudo calico node status</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>上诉能ping通且<code>sudo calico node status</code>能显示对端的信息说明环境搭建成功。</p>
<h2 id="测试工作"><a href="#测试工作" class="headerlink" title="测试工作"></a>测试工作</h2><p>安装<a href="http://docs.projectcalico.org/v2.0/getting-started/docker/tutorials/simple-policy" target="_blank" rel="noopener">官方文档</a>的说明，跨主机的容器通信很简单。只要给docker创建calico的network，然后创建container时设置这个network就可以。具体如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 进入calico-01，创建docker网络</span><br><span class="line">docker network create --driver calico --ipam-driver calico-ipam net1</span><br><span class="line"><span class="meta">#</span> 创建容器并设置网络为net1</span><br><span class="line">docker run -d --net net1 --name workload-A busybox tail -f /etc/hosts</span><br><span class="line"><span class="meta">#</span> 查看容器ip地址</span><br><span class="line">docker exec -it workload-A ip a # 查看到calixxx网络的地址为IP1</span><br><span class="line"><span class="meta">#</span> 进入calico-02，查看docker网络</span><br><span class="line">docker network ls # 运行这条命令可以看到net1的网络</span><br><span class="line"><span class="meta">#</span> 创建容器</span><br><span class="line">docker run -d --net net1 --name workload-B busybox tail -f /etc/hosts</span><br><span class="line"><span class="meta">#</span> 在calico-02的容器中ping calico-01的容器地址</span><br><span class="line">docker exec -it workload-B ping workload-A</span><br><span class="line">docker exec -it workload-B ping $IP1</span><br><span class="line"><span class="meta">#</span> 也可以直接在calico-02上ping calico-01的容器地址</span><br><span class="line">ping $IP1</span><br></pre></td></tr></table></figure>
<p>按照官方文档的说明，这里应该是能直接ping通的，但是这里就出现了上面一开始就说到的坑，并不能ping通，只有通一个主机的两个container直接可以ping。这个坑我首先在自己的azure上手动安装环境时就遇到了，同事帮忙查看了好久，看了iproute, iptables的各种信息，并用tcpdump进行抓包，但是都无法解决，认为可能是azure的问题。于是我又在自己的机器上安装使用virtualbox安装了两个虚拟机，结果还是一样。最后在Mac上直接使用vagrant也无效。这个问题直接浪费了我至少两天时间。最近同事终于发现原来是iptables会把这些包给drop掉。。。而解决这个问题的方法是需要设置calico的profile和policy对象，使得出入流量可以在两个主机之间互通。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 配置net1网络。在docker创建net1时就创建了这个profile，这里我们更改一些属性！</span><br><span class="line">cat &lt;&lt; EOF | calicoctl apply -f -</span><br><span class="line">- apiVersion: v1</span><br><span class="line">  kind: profile</span><br><span class="line">  metadata:</span><br><span class="line">    name: net1</span><br><span class="line">    labels:</span><br><span class="line">      role: net1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 为net1创建policy，运行所有出入流量！</span><br><span class="line">cat &lt;&lt; EOF | calicoctl create -f -</span><br><span class="line">- apiVersion: v1</span><br><span class="line">  kind: policy</span><br><span class="line">  metadata:</span><br><span class="line">    name: net1</span><br><span class="line">  spec:</span><br><span class="line">    order: 0</span><br><span class="line">    selector: role == 'net1'</span><br><span class="line">    ingress:</span><br><span class="line">    - action: allow</span><br><span class="line">    egress:</span><br><span class="line">    - action: allow</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>通过上面的设置，终于可以愉快的跨主机通信了^_^。<br>查看<code>ip route</code>可以发现，本地的ip直接走本地的calico创建的veth设备，其他主机的ip通过网卡直接路由到目标主机ip，然后交给目标主机的路由表处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">default via 10.0.2.2 dev enp0s3</span><br><span class="line">10.0.2.0/24 dev enp0s3  proto kernel  scope link  src 10.0.2.15</span><br><span class="line">172.17.8.0/24 dev enp0s8  proto kernel  scope link  src 172.17.8.101</span><br><span class="line">172.18.0.0/16 dev docker0  proto kernel  scope link  src 172.18.0.1 linkdown</span><br><span class="line"># 目的地址为192.168.50.64/26的请求通过主机上的enp0s8网卡发到172.17.8.102</span><br><span class="line">192.168.50.64/26 via 172.17.8.102 dev enp0s8  proto bird</span><br><span class="line">blackhole 192.168.84.192/26  proto bird</span><br><span class="line"># 本机container直接打到对应设备上</span><br><span class="line">192.168.84.209 dev calic18c1dc57ca  scope link</span><br></pre></td></tr></table></figure>
<h2 id="ipip-隧道通信"><a href="#ipip-隧道通信" class="headerlink" title="ipip 隧道通信"></a>ipip 隧道通信</h2><p>calico支持两个container之间通过ipip隧道通信。在这种模式下，calico会为我们在主机上创建tunl0设备。使用这个设备进行ip封装和拆解。</p>
<p>在打开ipip选项之前，可以先试用<code>ip link</code>看一下机器上的设备被没有tunl0设备。通过下面步骤打开</p>
<ol>
<li>执行<code>calicoctl config set ipip on</code>, 打开设置</li>
<li>按照<a href="http://docs.projectcalico.org/v2.0/usage/troubleshooting/faq#how-do-i-enable-ipip-and-nat-outgoing-on-an-ip-pool" target="_blank" rel="noopener">这里</a>的教程打开ipPool的ipip</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">calicoctl get ipPool -o yaml &gt; pool.yaml</span><br><span class="line"><span class="meta">#</span> 修改spec内容，设置ipip和nat-outgoing</span><br><span class="line"></span><br><span class="line">- apiVersion: v1</span><br><span class="line">  kind: ipPool</span><br><span class="line">  metadata:</span><br><span class="line">    cidr: 192.168.0.0/16</span><br><span class="line">  spec:</span><br><span class="line">    ipip:</span><br><span class="line">      enabled: true</span><br><span class="line">    nat-outgoing: true</span><br><span class="line"></span><br><span class="line">calicoctl replace -f pool.yaml</span><br></pre></td></tr></table></figure>
<p>通过上诉设置，就打开了calico的ipip支持。查看<code>ip route</code>可以看到和原来的不同:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">default via 10.0.2.2 dev enp0s3</span><br><span class="line">10.0.2.0/24 dev enp0s3  proto kernel  scope link  src 10.0.2.15</span><br><span class="line">172.17.8.0/24 dev enp0s8  proto kernel  scope link  src 172.17.8.101</span><br><span class="line">172.18.0.0/16 dev docker0  proto kernel  scope link  src 172.18.0.1 linkdown</span><br><span class="line"># 注意这里使用到tunl0设备，与前面不同</span><br><span class="line">192.168.50.64/26 via 172.17.8.102 dev tunl0  proto bird onlink</span><br><span class="line">blackhole 192.168.84.192/26  proto bird</span><br><span class="line"># 本机container直接打到对应设备上</span><br><span class="line">192.168.84.208 dev cali445d36d1804  scope link</span><br></pre></td></tr></table></figure>
<p>现在跨主机的通信通过tunl0设备而不是原来的enp0s8设备了。</p>
<p>这样ping容器时进行<code>tcpdump -i tunl0 icmp</code>可以看到有icmp包。<code>tcpdump -i cali445d36d1804 icmp</code>可以看到流量。</p>
<p><code>tcpdump -i enp0s8 | grep ipip</code>同样可以看到ipip报文，内容如图所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">06:35:48.321025 IP 172.17.8.102 &gt; 172.17.8.101: IP 192.168.50.97 &gt; 192.168.84.208: ICMP echo request, id 2304, seq 0, length 64 (ipip-proto-4)</span><br><span class="line">06:35:48.321149 IP 172.17.8.101 &gt; 172.17.8.102: IP 192.168.84.208 &gt; 192.168.50.97: ICMP echo reply, id 2304, seq 0, length 64 (ipip-proto-4)</span><br><span class="line">06:35:49.322821 IP 172.17.8.102 &gt; 172.17.8.101: IP 192.168.50.97 &gt; 192.168.84.208: ICMP echo request, id 2304, seq 1, length 64 (ipip-proto-4)</span><br><span class="line">06:35:49.322900 IP 172.17.8.101 &gt; 172.17.8.102: IP 192.168.84.208 &gt; 192.168.50.97: ICMP echo reply, id 2304, seq 1, length 64 (ipip-proto-4)</span><br></pre></td></tr></table></figure>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>这里简单的测试了calico网络的性能。测试环境是MacBook上创建的两个虚拟机。calico网络使用networkstatic/iperf3进行性能测试，host之间也适用iperf3测试。测试结果如下：</p>
<table>
<thead>
<tr>
<th>测试项</th>
<th>命令</th>
<th>Bandwidth</th>
<th>Retr</th>
</tr>
</thead>
<tbody>
<tr>
<td>主机网络</td>
<td><code>iperf3 -c 172.17.8.101 -n 10000M -O 3</code></td>
<td>2.25 Gbits/sec</td>
<td>55672</td>
</tr>
<tr>
<td>docker host</td>
<td><code>docker run --rm -it --net host networkstatic/iperf3 -c 172.17.8.101 -n 10000M -O 3</code></td>
<td>2.22 Gbits/sec</td>
<td>55285</td>
</tr>
<tr>
<td>calico</td>
<td><code>docker run --rm -it --net net1 networkstatic/iperf3 -c 192.168.84.209 -n 10000M -O 3</code></td>
<td>2.09 Gbits/sec</td>
<td>36470</td>
</tr>
<tr>
<td>calico-ipip</td>
<td><code>docker run --rm -it --net net1 networkstatic/iperf3 -c 192.168.84.208 -n 10000M -O 3</code></td>
<td>2.15 Gbits/sec</td>
<td>4516</td>
</tr>
</tbody>
</table>
<p>可以看到ipip的性能还要稍微好于非ipip模式，且在ipip模式下TCP的重传较少。总体来看，对比host模式，calico的性能损失不大。</p>
<p>对于上面的测试结果（ipip模式比非ipip模式要好）存在疑惑，因为实际上相比于非ipip模式，ipip模式下需要多经历一次ip包的封装。针对这个疑惑我在社区提了个<a href="https://github.com/projectcalico/calico/issues/621" target="_blank" rel="noopener">issue</a>。根据回复中的建议在iperf命令中加入了<code>-M 1440</code>设置mtu参数，结果显示非ipip模式实际是要比较好的，这比较符合常理。（注：1440是calico的tunl0的mtu值）</p>
<h1 id="自己动手"><a href="#自己动手" class="headerlink" title="自己动手"></a>自己动手</h1><p>calico实际上就是对本机容器ip在主机上建立路由，并将这些路由通过bgp协议告知其他主机。通过路由表的信息，达到主机垮主机的容器通信。<br>下面使用同事给的demo使用linux的ip命令工具来模拟calico的非ipip网络和ipip网络。</p>
<ol>
<li>首先创建两个虚拟机host1(dev enp0s8:172.17.8.101)和host2(dev enp0s8:172.17.8.102)，检查是否可以相互ping通</li>
<li><p>在host1上执行以下命令创建容器网络</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> netns内部ip, 假设本机上所有container的网段在192.168.41.0/24</span><br><span class="line">ip=192.168.41.2</span><br><span class="line">ctn=ctn1</span><br><span class="line">ip netns add $ctn</span><br><span class="line">ip li add dev veth_host type veth peer name veth_sbx</span><br><span class="line">ip link set dev veth_sbx netns $ctn</span><br><span class="line">ip netns exec $ctn ip ad add $ip dev veth_sbx</span><br><span class="line">ip netns exec $ctn ip link set dev veth_sbx up</span><br><span class="line">ip netns exec $ctn ip route add 169.254.1.1 dev veth_sbx</span><br><span class="line">ip netns exec $ctn ip route add default via 169.254.1.1 dev veth_sbx</span><br><span class="line">ip netns exec $ctn ip ad</span><br><span class="line">ip netns exec $ctn ip link set dev veth_sbx up</span><br><span class="line">ip link set dev veth_host up</span><br><span class="line">ip ad show veth_host</span><br><span class="line">ip netns exec $ctn ip neigh add 169.254.1.1 dev veth_sbx lladdr `cat /sys/class/net/veth_host/address` </span><br><span class="line">ip route add $ip dev veth_host</span><br><span class="line"><span class="meta">#</span> 打开ip_forward</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>
</li>
<li><p>将上诉脚本的ip地址改为192.168.42.2，在host2执行</p>
</li>
<li><p>执行以下步骤添加路由表项以达到跨主机container访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在host2执行下面命令</span><br><span class="line">ip route add 192.168.41.0/24 via 172.17.8.101 dev enp0s8</span><br><span class="line"># 在host1执行下面命令</span><br><span class="line">ip route add 192.168.42.0/24 via 172.17.8.102 dev enp0s8</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样就可以在主机或者容器网络空间内ping跨主机的container ip了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在host1 ping host2的container</span><br><span class="line">ip netns exec ctn1 ping 192.168.42.2</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通过上诉步骤，就模拟了calico的默认网络。</p>
<p>通过之前的描述，calico实际还支持ipip模式的跨主机通信，原理就是通过tunnel设备对原始ip报文进行封装。只需要对上述脚本做一些修改就可以：</p>
<ol>
<li>在两台主机上将上诉过程中的第4步添加的路由规则去掉</li>
<li><p>在host1上执行以下脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ipip=192.168.41.3</span><br><span class="line"><span class="meta">#</span> 这个命令会生成一个tunl0设备</span><br><span class="line">modprobe ipip</span><br><span class="line">ip link set tunl0 up</span><br><span class="line">ip a add $ipip brd + dev tunl0</span><br><span class="line"><span class="meta">#</span> 注意这里的路由规则，前面已经提到过，使用tunl0设备！最后一个参数onlink是必须的，具体作用参考[这里](http://lartc.vger.kernel.narkive.com/XgcjFTGM/aw-onlink-option-for-ip-route)</span><br><span class="line">ip r add 192.168.42.0/24 via 172.17.8.102 dev tunl0 proto bird onlink</span><br></pre></td></tr></table></figure>
</li>
<li><p>在host2上执行类似上诉步骤</p>
</li>
<li>重新进入网络空间ping跨主机container ip</li>
<li><p>可以在对端的enp0s8网卡上使用tcpdump进行截包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -vvnneSs 0 -i enp0s8</span><br><span class="line"></span><br><span class="line">07:41:03.985150 08:00:27:d5:4b:b1 &gt; 08:00:27:29:bc:de, ethertype IPv4 (0x0800), length 118: (tos 0x0, ttl 63, id 55151, offset 0, flags [DF], proto IPIP (4), length 104)</span><br><span class="line">    172.17.8.101 &gt; 172.17.8.103: (tos 0x0, ttl 63, id 16085, offset 0, flags [DF], proto ICMP (1), length 84)</span><br><span class="line">    192.168.41.2 &gt; 192.168.43.2: ICMP echo request, id 15973, seq 30, length 64</span><br><span class="line">07:41:03.985243 08:00:27:29:bc:de &gt; 08:00:27:d5:4b:b1, ethertype IPv4 (0x0800), length 118: (tos 0x0, ttl 63, id 32595, offset 0, flags [none], proto IPIP (4), length 104)</span><br><span class="line">    172.17.8.103 &gt; 172.17.8.101: (tos 0x0, ttl 63, id 42711, offset 0, flags [none], proto ICMP (1), length 84)</span><br><span class="line">    192.168.43.2 &gt; 192.168.41.2: ICMP echo reply, id 15973, seq 30, length 64</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>ipip相对于非ipip模式会有一些性能的损失，但是好处在于ipip模式下可以进行跨网段的主机间容器通信！将上诉的脚本的两个不同网段的主机上测试可以验证这个结果。</p>
</div><div class="tags"><a href="/tags/network/">network</a><a href="/tags/calico/">calico</a></div><div class="post-nav"><a class="pre" href="/2017/03/30/iptables-quick-start/">iptables quick start</a><a class="next" href="/2017/03/07/tcpdump-quick-start/">tcpdump quick start</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://chenlingpeng.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-System/">Distributed System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/lang/">lang</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/others/" style="font-size: 15px;">others</a> <a href="/tags/neural-network/" style="font-size: 15px;">neural network</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/Distributed-System/" style="font-size: 15px;">Distributed System</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/tcpdump/" style="font-size: 15px;">tcpdump</a> <a href="/tags/tc/" style="font-size: 15px;">tc</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/kubelet/" style="font-size: 15px;">kubelet</a> <a href="/tags/lang/" style="font-size: 15px;">lang</a> <a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/calico/" style="font-size: 15px;">calico</a> <a href="/tags/ebpf/" style="font-size: 15px;">ebpf</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/19/ebpf-sockhash-debug/">ebpf/sockhash 内核bug定位分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/08/linux-kernel-build-and-submit-patch/">linux 内核源码修改编译与patch提交</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/07/ebpf-intro/">ebpf intro</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/23/k8s-service-ip-problem/">k8s service ip problem</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/04/k8s-floatingip-evolution/">k8s floatingip evolution</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/22/sriov-getting-start/">sriov getting start</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/18/ipvs-attempt/">ipvs attempt</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/30/iptables-quick-start/">iptables quick start</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/16/calico-getting-start/">calico getting start</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/tcpdump-quick-start/">tcpdump quick start</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">chenlingpeng.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>